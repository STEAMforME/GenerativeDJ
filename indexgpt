<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real-Time Music Visualizer + DJ</title>

  <!-- Three.js (r128) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls for basic camera movement -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.min.js"></script>
  <!-- Cannon.js (optional physics) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Font Awesome for UI icons -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/>

  <style>
    /* =========================
       GLOBAL THEME + LAYOUT
       ========================= */
    :root{
      --bg:#0a0b0f;            /* base background */
      --panel:#11131a;         /* UI panel background */
      --panel-2:#0f1117;       /* secondary surface */
      --fg:#e6e9ef;            /* primary text */
      --muted:#7f8aa3;         /* muted text */
      --accent:#00e5ff;        /* cyan accent */
      --accent-2:#7c4dff;      /* purple accent */
      --good:#2bd576;          /* green accent */
      --warn:#ffb020;          /* amber accent */
      --danger:#ff5577;        /* red accent */
      --grid-gap:1rem;
      --radius:14px;
      --shadow:0 10px 30px rgba(0,0,0,0.35);
    }
    *{box-sizing:border-box}
    html,body{
      margin:0;
      height:100%;
      color:var(--fg);
      background:var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden; /* the 3D canvas sits full screen */
    }

    /* 3D canvas fills screen, UI floats above it */
    #stage{
      position:fixed;
      inset:0;
      z-index:0;
      background: radial-gradient(1200px 600px at 50% 100%, rgba(0,229,255,0.12), transparent 70%),
                  radial-gradient(900px 900px at 10% 10%, rgba(124,77,255,0.10), transparent 60%),
                  var(--bg);
    }

    /* Top utility bar */
    .topbar{
      position:fixed;
      z-index:2;
      top:0;
      left:0;
      right:0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1rem;
      padding:.8rem 1rem;
      backdrop-filter: blur(10px);
      background: linear-gradient(to right, rgba(17,19,26,0.75), rgba(17,19,26,0.55));
      border-bottom:1px solid rgba(255,255,255,0.06);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:.75rem;
      font-weight:700;
      letter-spacing:.3px;
    }
    .brand .dot{
      width:10px;height:10px;border-radius:50%;
      background: conic-gradient(from 0deg, var(--accent), var(--accent-2));
      box-shadow:0 0 12px rgba(0,229,255,.6);
    }
    .top-actions{display:flex;align-items:center;gap:.6rem}
    .btn{
      display:inline-flex;align-items:center;gap:.5rem;
      padding:.55rem .8rem;border-radius:10px;border:1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(20,22,29,.9), rgba(14,16,22,.9));
      color:var(--fg);cursor:pointer;box-shadow:var(--shadow);
      transition:transform .12s ease, box-shadow .12s ease, background .2s ease;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn:active{transform:translateY(0)}
    .btn.primary{
      border-color: rgba(0,229,255,.25);
      background: linear-gradient(180deg, rgba(0,229,255,.18), rgba(0,229,255,.05));
      box-shadow: 0 8px 26px rgba(0,229,255,.2);
    }
    .btn.toggle.on{outline:2px solid var(--accent)}

    /* Main UI shell */
    .shell{
      position:fixed;inset:56px 0 0 0; /* under topbar */
      z-index:1;
      display:grid;
      grid-template-columns: 1fr minmax(260px, 520px) 1fr;
      gap: var(--grid-gap);
      padding: var(--grid-gap);
      pointer-events:none; /* allow camera orbit on empty areas */
    }
    .panel{
      pointer-events:auto; /* UI interactive */
      background: linear-gradient(160deg, rgba(20,22,29,.92), rgba(15,17,24,.92));
      border:1px solid rgba(255,255,255,0.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: .9rem;
      min-height: 280px;
    }

    /* Turntables */
    .deck{
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap:.75rem;
    }
    .plabel{
      display:flex;align-items:center;justify-content:space-between;
      font-size:.9rem;color:var(--muted)
    }
    .disc-wrap{
      aspect-ratio:1/1;
      border-radius:50%;
      background: radial-gradient(120px 120px at 50% 50%, rgba(255,255,255,0.06), rgba(255,255,255,0.0)),
                  conic-gradient(from 0deg, rgba(124,77,255,.12), rgba(0,229,255,.12), rgba(124,77,255,.12));
      border:1px solid rgba(255,255,255,.06);
      position:relative;
      overflow:hidden;
      cursor:grab;
    }
    .disc-wrap:active{cursor:grabbing}
    .disc {
      position:absolute;inset:6%;
      border-radius:50%;
      background:
        radial-gradient(60px 60px at 50% 50%, rgba(255,255,255,0.08), rgba(255,255,255,0) 60%),
        repeating-conic-gradient(from 0deg, rgba(255,255,255,0.06) 0 6deg, rgba(255,255,255,0) 6deg 12deg);
      border:1px solid rgba(255,255,255,.08);
      filter: drop-shadow(0 10px 20px rgba(0,0,0,.5));
      transform: rotate(0deg);
      transition: box-shadow .25s ease;
    }
    .spindle{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:14%;height:14%;border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #fff, #ddd 45%, #666 60%, #222 80%);
      box-shadow: inset 0 0 10px rgba(0,0,0,.6);
      border:2px solid #111;
    }
    .deck-controls{
      display:flex;align-items:center;justify-content:space-between;gap:.5rem;flex-wrap:wrap
    }
    .deck-controls .btn{flex:1 1 90px;justify-content:center}

    /* Mixer center panel */
    .mixer{
      display:grid;grid-template-rows:auto auto 1fr;gap: .9rem;
    }
    .xfader{
      padding:.8rem;border-radius:12px;background:var(--panel-2);
      border:1px solid rgba(255,255,255,.06);
    }
    .xfader label{display:flex;align-items:center;justify-content:space-between;color:var(--muted);font-size:.9rem}
    .xfader input[type="range"]{width:100%}
    input[type="range"]{
      -webkit-appearance:none;appearance:none;height:6px;border-radius:999px;
      background:linear-gradient(90deg, var(--accent), var(--accent-2));
      outline:none;opacity:.95;box-shadow: inset 0 0 10px rgba(0,0,0,.5);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;appearance:none;width:22px;height:22px;border-radius:50%;
      border:2px solid rgba(255,255,255,.8);
      background: radial-gradient(circle at 30% 30%, #fff, #dff, #5ff);
      box-shadow:0 4px 16px rgba(0,229,255,.45);
      cursor:pointer;
    }
    .pads{
      display:grid;grid-template-columns: repeat(3, minmax(0,1fr));gap:.75rem
    }
    .pad{
      position:relative;
      aspect-ratio:1/1;border-radius:12px;cursor:pointer;
      background: linear-gradient(160deg, rgba(0,229,255,.08), rgba(124,77,255,.08));
      border:1px solid rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      font-weight:700;letter-spacing:.4px;color:#def;
      box-shadow:var(--shadow);
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .pad:active{transform:translateY(1px)}
    .pad small{
      position:absolute;bottom:6px;left:8px;color:var(--muted);font-size:.7rem
    }

    /* Educational overlay panel */
    .edu{
      position:fixed;right:1rem;bottom:1rem;z-index:3;max-width:min(520px, 92vw);
      display:none; /* toggled by button */
      background: linear-gradient(180deg, rgba(18,20,28,.95), rgba(12,14,20,.95));
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;box-shadow: var(--shadow);
      padding:1rem;
    }
    .edu.on{display:block}
    .edu h3{margin:.2rem 0 .6rem 0;font-size:1.05rem}
    .edu .scroll{
      max-height:40vh;overflow:auto;padding-right:.2rem;
      border-top:1px dashed rgba(255,255,255,.08);margin-top:.5rem
    }
    .edu .msg{font-size:.9rem;color:#cfe;opacity:.95;margin:.6rem 0}
    .edu code{background:#0f1320;border:1px solid rgba(255,255,255,.07);padding:.08rem .35rem;border-radius:6px}

    /* Footer helper on small screens */
    .footer-tip{
      position:fixed;left:0;right:0;bottom:0;z-index:2;
      text-align:center;color:var(--muted);
      padding:.35rem .75rem;font-size:.85rem;
      background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.35));
      pointer-events:none;
    }

    /* Responsive: stack columns on narrow screens */
    @media (max-width: 980px){
      .shell{
        grid-template-columns: 1fr;
        grid-auto-rows:auto;
        overflow:auto;
      }
      .panel{min-height:unset}
    }
  </style>
</head>
<body>
  <!-- 3D stage -->
  <canvas id="stage"></canvas>

  <!-- Top bar -->
  <div class="topbar">
    <div class="brand">
      <span class="dot"></span>
      <span>Audio Visualizer + DJ</span>
    </div>
    <div class="top-actions">
      <button id="audioStart" class="btn primary"><i class="fa-solid fa-bolt"></i> Init Audio</button>
      <button id="eduToggle" class="btn toggle"><i class="fa-solid fa-graduation-cap"></i> Educational Mode</button>
      <button id="camReset" class="btn"><i class="fa-solid fa-camera-rotate"></i> Reset View</button>
      <a class="btn" href="#" id="recNotSupported" title="Recorder stub"><i class="fa-solid fa-record-vinyl"></i> Record</a>
    </div>
  </div>

  <!-- Main UI -->
  <div class="shell">
    <!-- Deck A -->
    <section class="panel deck" id="deckA">
      <div class="plabel">
        <strong>Deck A</strong>
        <span id="deckATime">00:00</span>
      </div>
      <div class="disc-wrap" data-deck="A" title="Drag to scratch">
        <div class="disc" id="discA">
          <div class="spindle"></div>
        </div>
      </div>
      <div class="deck-controls">
        <label class="btn" title="Load audio">
          <i class="fa-solid fa-upload"></i> Load
          <input id="loadA" type="file" accept="audio/*" style="display:none">
        </label>
        <button id="playA" class="btn"><i class="fa-solid fa-play"></i> Play</button>
        <button id="pauseA" class="btn"><i class="fa-solid fa-pause"></i> Pause</button>
      </div>
    </section>

    <!-- Mixer + Pads -->
    <section class="panel mixer">
      <div class="xfader">
        <label>
          <span>Crossfader</span>
          <span id="xfLabel">Center</span>
        </label>
        <input id="xfader" type="range" min="0" max="1" step="0.001" value="0.5" />
      </div>

      <div class="xfader" style="display:grid;grid-template-columns:1fr 1fr;gap:.75rem">
        <div>
          <label>
            <span>Master Volume</span>
            <span id="volLabel">0.85</span>
          </label>
          <input id="masterVol" type="range" min="0" max="1" step="0.001" value="0.85" />
        </div>
        <div>
          <label>
            <span>Smoothing</span>
            <span id="smLabel">0.85</span>
          </label>
          <input id="smoothing" type="range" min="0" max="0.99" step="0.01" value="0.85" />
        </div>
      </div>

      <div>
        <div style="display:flex;align-items:center;justify-content:space-between;margin:.2rem 0 .6rem 0;color:var(--muted)">
          <strong>Beat Pads</strong>
          <span style="font-size:.85rem">synth generated</span>
        </div>
        <div class="pads">
          <button class="pad" data-pad="kick">KICK<small>Pad 1</small></button>
          <button class="pad" data-pad="snare">SNARE<small>Pad 2</small></button>
          <button class="pad" data-pad="hat">HAT<small>Pad 3</small></button>
          <button class="pad" data-pad="clap">CLAP<small>Pad 4</small></button>
          <button class="pad" data-pad="tom">TOM<small>Pad 5</small></button>
          <button class="pad" data-pad="fx">FX<small>Pad 6</small></button>
        </div>
      </div>
    </section>

    <!-- Deck B -->
    <section class="panel deck" id="deckB">
      <div class="plabel">
        <strong>Deck B</strong>
        <span id="deckBTime">00:00</span>
      </div>
      <div class="disc-wrap" data-deck="B" title="Drag to scratch">
        <div class="disc" id="discB">
          <div class="spindle"></div>
        </div>
      </div>
      <div class="deck-controls">
        <label class="btn" title="Load audio">
          <i class="fa-solid fa-upload"></i> Load
          <input id="loadB" type="file" accept="audio/*" style="display:none">
        </label>
        <button id="playB" class="btn"><i class="fa-solid fa-play"></i> Play</button>
        <button id="pauseB" class="btn"><i class="fa-solid fa-pause"></i> Pause</button>
      </div>
    </section>
  </div>

  <!-- Educational overlay -->
  <aside id="edu" class="edu" aria-live="polite">
    <h3><i class="fa-solid fa-graduation-cap"></i> Educational Mode</h3>
    <div class="msg">
      <strong>Basics</strong>: <em>Amplitude</em> is signal strength. <em>Frequency</em> is cycles per second. Bass is low freq, mids are middle, highs are treble.
      Visualizer maps bass to building height. Pulses and color shifts respond to spectral changes.
    </div>
    <div class="msg">
      <strong>Audio Graph</strong>:
      <code>DeckA/B → deckGain → crossfade → master → analyser → destination</code>.
      Pads feed the same master so they affect visuals.
    </div>
    <div id="eduLog" class="scroll"></div>
  </aside>

  <div class="footer-tip">Tip: drag a turntable to scratch, move camera with mouse, toggle Educational Mode for inline explanations.</div>

  <script>
    /* ==========================================================
       REAL-TIME DJ + VISUALIZER
       Single file. Pure HTML, CSS, JS.
       Web Audio API for audio graph. Three.js for visuals.
       Cannon.js used lightly for reactive physics spheres.
       ========================================================== */

    /* ----------------------------
       UTILS
       ---------------------------- */
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const fmtTime = sec=>{
      if(!isFinite(sec)||sec<0) sec=0;
      const m = Math.floor(sec/60);
      const s = Math.floor(sec%60);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    };

    /* ----------------------------
       EDUCATIONAL MODE LOGGING
       ---------------------------- */
    const edu = {
      on:false,
      el: $('#edu'),
      logEl: $('#eduLog'),
      toggle(){
        this.on = !this.on;
        this.el.classList.toggle('on', this.on);
        $('#eduToggle').classList.toggle('on', this.on);
        if(this.on) this.msg('Educational mode enabled. Explanations will appear here.');
      },
      msg(text){
        if(!this.on) return;
        const div = document.createElement('div');
        div.className='msg';
        div.textContent = text;
        this.logEl.appendChild(div);
        this.logEl.scrollTop = this.logEl.scrollHeight;
      }
    };
    $('#eduToggle').addEventListener('click', ()=>edu.toggle());

    /* ----------------------------
       WEB AUDIO SETUP
       ---------------------------- */
    let audioCtx;
    let masterGain, analyser, merger;
    let deckA = null;
    let deckB = null;
    let padsGain = null;

    // State used for UI and analysis
    const state = {
      started:false,
      fftSize:1024,             // power of two. 512..2048 is good for visuals
      smoothing:0.85,           // 0..0.99. Higher is smoother
      xf:0.5,                   // crossfader 0..1
      master:0.85,
      spectrum:new Uint8Array(512),
      waveform:new Float32Array(1024),
      timeA:0,
      timeB:0
    };

    // Equal-power crossfade law
    function setCrossfader(x){
      state.xf = x;
      const a = Math.cos(x * 0.5 * Math.PI);
      const b = Math.cos((1 - x) * 0.5 * Math.PI);
      if(deckA?.gain) deckA.gain.gain.value = a*a;
      if(deckB?.gain) deckB.gain.gain.value = b*b;
      $('#xfLabel').textContent = x<0.45 ? 'Left' : x>0.55 ? 'Right' : 'Center';
      edu.msg(`Crossfader set to ${x.toFixed(2)}. Equal-power law to avoid dips in the center.`);
    }

    function initAudioGraph(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // Master bus
      masterGain = audioCtx.createGain();
      masterGain.gain.value = state.master;

      // Analyser after master for combined output
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = state.fftSize;
      analyser.smoothingTimeConstant = state.smoothing;
      state.spectrum = new Uint8Array(analyser.frequencyBinCount);
      state.waveform = new Float32Array(analyser.fftSize);

      // Decks and pads
      deckA = makeDeck();
      deckB = makeDeck();
      padsGain = audioCtx.createGain();
      padsGain.gain.value = 0.9;

      // Graph wiring
      deckA.gain.connect(masterGain);
      deckB.gain.connect(masterGain);
      padsGain.connect(masterGain);
      masterGain.connect(analyser);
      analyser.connect(audioCtx.destination);

      setCrossfader(state.xf);
      edu.msg(`AudioContext initialized at ${audioCtx.sampleRate} Hz. Analyser fftSize=${state.fftSize}, smoothing=${state.smoothing}.`);
    }

    $('#audioStart').addEventListener('click', async()=>{
      initAudioGraph();
      await audioCtx.resume();
      state.started = true;
      $('#audioStart').textContent='Audio Ready';
      edu.msg('Audio ready. Load files or hit pads. Visuals now respond to master output.');
    });

    // Deck abstraction
    function makeDeck(){
      const gain = audioCtx.createGain();
      gain.gain.value = 0; // crossfader controls actual audible level

      return {
        buffer:null,
        src:null,
        gain,
        isPlaying:false,
        startedAt:0,   // audioCtx.currentTime when started
        pausedAt:0,    // seconds into buffer when paused
        playbackRate:1,

        async load(file){
          const arr = await file.arrayBuffer();
          this.buffer = await audioCtx.decodeAudioData(arr);
          this.pausedAt = 0;
          this.startedAt = 0;
          edu.msg(`Loaded "${file.name}" (${(this.buffer.duration).toFixed(1)} s, ${this.buffer.numberOfChannels} ch).`);
        },
        _spawnSource(){
          if(!this.buffer) return null;
          const src = audioCtx.createBufferSource();
          src.buffer = this.buffer;
          src.loop = true; // DJ loops by default for demo
          src.playbackRate.value = this.playbackRate;
          src.connect(this.gain);
          this.src = src;
          return src;
        },
        play(){
          if(!this.buffer) return;
          if(this.isPlaying) return;
          const src = this._spawnSource();
          if(!src) return;
          src.start(0, this.pausedAt % this.buffer.duration);
          this.startedAt = audioCtx.currentTime - this.pausedAt / this.playbackRate;
          this.isPlaying = true;
          edu.msg('Deck started. Loop on. playbackRate=' + this.playbackRate.toFixed(2));
        },
        pause(){
          if(this.src){
            // compute current offset before stopping
            const played = (audioCtx.currentTime - this.startedAt) * this.playbackRate;
            this.pausedAt = (this.pausedAt + played) % (this.buffer?.duration || 0);
            this.src.stop();
            this.src.disconnect();
            this.src = null;
          }
          this.isPlaying = false;
          edu.msg('Deck paused.');
        },
        setRate(rate){
          this.playbackRate = rate;
          if(this.src){
            this.src.playbackRate.setValueAtTime(rate, audioCtx.currentTime);
          }
        },
        currentTime(){
          if(!this.buffer) return 0;
          if(!this.isPlaying) return this.pausedAt;
          const played = (audioCtx.currentTime - this.startedAt) * this.playbackRate;
          return (this.pausedAt + played) % this.buffer.duration;
        }
      };
    }

    // File inputs
    $('#loadA').addEventListener('change', e=>{
      const f = e.target.files[0];
      if(!f) return;
      initAudioGraph();
      deckA.load(f);
    });
    $('#loadB').addEventListener('change', e=>{
      const f = e.target.files[0];
      if(!f) return;
      initAudioGraph();
      deckB.load(f);
    });

    // Deck transport buttons
    $('#playA').addEventListener('click', ()=>{initAudioGraph(); deckA.play();});
    $('#pauseA').addEventListener('click', ()=>deckA.pause());
    $('#playB').addEventListener('click', ()=>{initAudioGraph(); deckB.play();});
    $('#pauseB').addEventListener('click', ()=>deckB.pause());

    // Master controls
    $('#xfader').addEventListener('input', e=> setCrossfader(parseFloat(e.target.value)));
    $('#masterVol').addEventListener('input', e=>{
      const v = parseFloat(e.target.value);
      state.master = v;
      if(masterGain) masterGain.gain.value = v;
      $('#volLabel').textContent = v.toFixed(2);
      edu.msg(`Master volume set to ${v.toFixed(2)}.`);
    });
    $('#smoothing').addEventListener('input', e=>{
      const v = parseFloat(e.target.value);
      state.smoothing = v;
      if(analyser) analyser.smoothingTimeConstant = v;
      $('#smLabel').textContent = v.toFixed(2);
      edu.msg(`Analyser smoothingTimeConstant set to ${v.toFixed(2)}. Higher smooths more, slower response.`);
    });

    /* ----------------------------
       SCRATCHING
       Mapping pointer motion on a disc to playbackRate.
       We compute angular velocity around disc center.
       ---------------------------- */
    function bindScratch(discEl, deck){
      let dragging=false;
      let lastAngle=0;
      let lastTime=0;

      function getAngle(ev){
        const rect = discEl.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        const x = (ev.touches ? ev.touches[0].clientX : ev.clientX) - cx;
        const y = (ev.touches ? ev.touches[0].clientY : ev.clientY) - cy;
        return Math.atan2(y, x); // radians
      }
      function onDown(ev){
        if(!state.started){ initAudioGraph(); }
        dragging = true;
        lastAngle = getAngle(ev);
        lastTime = performance.now();
        ev.preventDefault();
        edu.msg('Scratch start. Drag around center to change playbackRate. Negative rate plays backward.');
      }
      function onMove(ev){
        if(!dragging) return;
        const a = getAngle(ev);
        const now = performance.now();
        const dt = (now - lastTime)/1000;
        let da = a - lastAngle;
        // Wrap to shortest path
        if(da > Math.PI) da -= 2*Math.PI;
        if(da < -Math.PI) da += 2*Math.PI;
        // Angular velocity to rate mapping. Tuned constant.
        const rate = clamp(da/dt * 0.25, -3.0, 3.0);
        deck.setRate(rate);
        // Rotate disc visually to reinforce movement
        const currentRot = parseFloat(discEl.dataset.rot || '0');
        const deg = currentRot + (da*180/Math.PI);
        discEl.style.transform = `rotate(${deg}deg)`;
        discEl.dataset.rot = deg;
        lastAngle = a; lastTime = now;
      }
      function onUp(){
        if(!dragging) return;
        dragging = false;
        // Spring back to normal rate
        const back = ()=>{
          const r = deck.playbackRate;
          const target = 1.0;
          const nr = lerp(r, target, 0.2);
          deck.setRate(nr);
          if(Math.abs(nr-target)>0.01) requestAnimationFrame(back);
          else deck.setRate(1.0);
        };
        back();
        edu.msg('Scratch end. playbackRate eased back to 1.0.');
      }

      discEl.parentElement.addEventListener('mousedown', onDown);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);

      discEl.parentElement.addEventListener('touchstart', onDown, {passive:false});
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp);
    }
    bindScratch($('#discA'), deckA);
    bindScratch($('#discB'), deckB);

    /* ----------------------------
       BEAT PADS
       Pure Web Audio synthesis. Short percussive voices.
       ---------------------------- */
    function trigKick(){
      if(!audioCtx) initAudioGraph();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(140, t0);
      o.frequency.exponentialRampToValueAtTime(50, t0+0.15);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(1.0, t0+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+0.3);
      o.connect(g).connect(padsGain);
      o.start(t0); o.stop(t0+0.35);
    }
    function trigSnare(){
      const t0 = audioCtx.currentTime;
      // noise burst
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*0.2, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*Math.pow(1-i/data.length, 2);
      const n = audioCtx.createBufferSource(); n.buffer=buffer;
      const band = audioCtx.createBiquadFilter(); band.type='bandpass'; band.frequency.value=1800; band.Q.value=0.8;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.8, t0+0.004);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+0.18);
      n.connect(band).connect(g).connect(padsGain);
      n.start(t0); n.stop(t0+0.2);
      // add body
      const o = audioCtx.createOscillator(); o.type='triangle';
      const og = audioCtx.createGain();
      o.frequency.setValueAtTime(200, t0);
      og.gain.setValueAtTime(0.0001, t0);
      og.gain.exponentialRampToValueAtTime(0.4, t0+0.006);
      og.gain.exponentialRampToValueAtTime(0.0001, t0+0.12);
      o.connect(og).connect(padsGain);
      o.start(t0); o.stop(t0+0.14);
    }
    function trigHat(){
      const t0 = audioCtx.currentTime;
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*0.08, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1);
      const n = audioCtx.createBufferSource(); n.buffer=buffer;
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; hp.Q.value=0.7;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.6, t0+0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+0.07);
      n.connect(hp).connect(g).connect(padsGain);
      n.start(t0); n.stop(t0+0.08);
    }
    function trigClap(){ trigSnare(); setTimeout(trigSnare, 40); }
    function trigTom(){
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator(); o.type='sine';
      const g = audioCtx.createGain();
      o.frequency.setValueAtTime(180, t0);
      o.frequency.exponentialRampToValueAtTime(90, t0+0.3);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.7, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+0.32);
      o.connect(g).connect(padsGain);
      o.start(t0); o.stop(t0+0.34);
    }
    function trigFX(){
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator(); o.type='sawtooth';
      const g = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200; lp.Q.value=10;
      o.frequency.setValueAtTime(200, t0);
      o.frequency.exponentialRampToValueAtTime(20, t0+1.0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.6, t0+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+1.0);
      o.connect(lp).connect(g).connect(padsGain);
      o.start(t0); o.stop(t0+1.05);
    }

    $$('.pad').forEach(p=>{
      p.addEventListener('click', ()=>{
        if(!audioCtx) initAudioGraph();
        const which=p.dataset.pad;
        if(which==='kick') trigKick();
        else if(which==='snare') { trigSnare(); pulse(0.9); }
        else if(which==='hat') trigHat();
        else if(which==='clap') trigClap();
        else if(which==='tom') trigTom();
        else trigFX();
        p.animate([{transform:'translateY(0)'},{transform:'translateY(2px)'}], {duration:90});
        edu.msg(`Pad "${which}" fired. This sound also feeds analyser for visuals.`);
      });
    });

    /* ----------------------------
       THREE.JS VISUALIZER
       City grid that responds to bass.
       Shader energy field and audio-reactive particles.
       Snare pulses kick physics spheres via Cannon.js.
       ---------------------------- */
    const canvas = $('#stage');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    camera.position.set(0, 16, 26);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0x88ccee, 0x111122, 0.8);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10,20,10);
    scene.add(hemi, dir);

    // Ground plane
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200,200,1,1),
      new THREE.MeshStandardMaterial({color:0x0b0d12, metalness:0.1, roughness:0.85})
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // City buildings as InstancedMesh for performance
    const GRID = 20;                     // 20x20 grid
    const COUNT = GRID*GRID;
    const dummy = new THREE.Object3D();
    const boxGeo = new THREE.BoxGeometry(0.8, 1, 0.8);
    const boxMat = new THREE.MeshStandardMaterial({
      color:0x112033, metalness:0.3, roughness:0.4, emissive:0x071a2a, emissiveIntensity:0.4
    });
    const buildings = new THREE.InstancedMesh(boxGeo, boxMat, COUNT);
    let idx=0;
    for(let ix=0; ix<GRID; ix++){
      for(let iz=0; iz<GRID; iz++){
        const x = (ix - GRID/2) * 1.2;
        const z = (iz - GRID/2) * 1.2;
        dummy.position.set(x, 0.5, z);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        buildings.setMatrixAt(idx++, dummy.matrix);
      }
    }
    buildings.instanceMatrix.needsUpdate = true;
    scene.add(buildings);

    // Audio data as DataTexture for shader usage
    const FFT_TEX_SIZE = 128; // we will pack first 128 bins
    const fftData = new Uint8Array(FFT_TEX_SIZE*4); // RGBA
    const fftTex = new THREE.DataTexture(fftData, FFT_TEX_SIZE, 1, THREE.RGBAFormat);
    fftTex.needsUpdate = true;

    // Energy field shader plane behind city
    const energyUniforms = {
      uTime: {value:0},
      uFFT: {value:fftTex},
      uPulse: {value:0},   // snare pulse
      uAmp: {value:0}      // overall amplitude
    };
    const energyMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      uniforms: energyUniforms,
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uFFT;
        uniform float uTime;
        uniform float uPulse;
        uniform float uAmp;

        // sample normalized spectrum value 0..1 at x in 0..1
        float spec(float x){
          vec2 uv = vec2(x, 0.5);
          return texture2D(uFFT, uv).r;
        }
        void main(){
          // radial field with waves modulated by bass and treble
          float bass = spec(0.05);
          float treble = spec(0.8);
          float glow = pow(1.0 - distance(vUv, vec2(0.5)), 2.0);
          float wave = 0.5 + 0.5*sin(10.0*vUv.x + uTime*2.0 + bass*12.0);
          float pulse = uPulse * exp(-8.0*distance(vUv, vec2(0.5,0.55)));
          float val = glow*wave + pulse + 0.15*uAmp;

          vec3 col = mix(vec3(0.02,0.1,0.18), vec3(0.0,0.9,1.0), val);
          col += treble*vec3(0.3,0.1,0.6);

          gl_FragColor = vec4(col, 0.35 + 0.35*val);
        }
      `
    });
    const energyPlane = new THREE.Mesh(new THREE.PlaneGeometry(60,40), energyMat);
    energyPlane.position.set(0,8,-12);
    scene.add(energyPlane);

    // Particle system that pops on snares
    const PCOUNT = 300;
    const pGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(PCOUNT*3);
    const speeds = new Float32Array(PCOUNT);
    for(let i=0;i<PCOUNT;i++){
      positions[i*3+0] = (Math.random()-0.5)*16;
      positions[i*3+1] = Math.random()*8+1;
      positions[i*3+2] = (Math.random()-0.5)*16;
      speeds[i] = Math.random()*0.02+0.005;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    pGeo.setAttribute('speed', new THREE.BufferAttribute(speeds,1));
    const pMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      uniforms:{
        uTime:{value:0},
        uPulse:{value:0}
      },
      vertexShader: `
        attribute float speed;
        uniform float uTime;
        uniform float uPulse;
        varying float vL;
        void main(){
          vec3 pos = position;
          pos.y += sin(uTime*2.0 + pos.x*0.2 + pos.z*0.1)*0.2;
          pos.x += sin(uTime*speed + pos.y*0.3)*0.1;
          pos.z += cos(uTime*speed + pos.x*0.2)*0.1;
          // pulse pushes outward
          pos.xy *= (1.0 + 0.3*uPulse);
          vL = speed;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
          gl_PointSize = 2.0 + 14.0*(0.3+speed) * (1.0 + 0.6*uPulse) / length(gl_Position.xyz);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying float vL;
        uniform float uPulse;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float alpha = smoothstep(0.5, 0.0, d);
          vec3 c = mix(vec3(0.0,0.6,1.0), vec3(0.7,0.3,1.0), vL*2.0);
          c += uPulse*vec3(0.4,0.4,0.1);
          gl_FragColor = vec4(c, alpha);
        }
      `
    });
    const particles = new THREE.Points(pGeo, pMat);
    scene.add(particles);

    // Physics spheres that pop on snares
    const world = new CANNON.World();
    world.gravity.set(0,-9.82,0);
    const groundBody = new CANNON.Body({mass:0, shape:new CANNON.Plane()});
    groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    world.addBody(groundBody);
    const sphereShape = new CANNON.Sphere(0.3);
    const physSpheres = []; // { body, mesh }
    function spawnSphere(){
      const body = new CANNON.Body({mass:1, shape:sphereShape});
      body.position.set((Math.random()-0.5)*6, 4+Math.random()*2, (Math.random()-0.5)*6);
      body.applyImpulse(new CANNON.Vec3((Math.random()-0.5)*2, 4, (Math.random()-0.5)*2));
      world.addBody(body);
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16),
        new THREE.MeshStandardMaterial({color:0x22ffee, emissive:0x114455, emissiveIntensity:0.6, metalness:0.2, roughness:0.3}));
      scene.add(mesh);
      physSpheres.push({body, mesh, born: performance.now()});
      if(physSpheres.length>24){
        const s = physSpheres.shift();
        world.remove(s.body);
        scene.remove(s.mesh);
      }
    }

    // Resize
    function resize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    $('#camReset').addEventListener('click', ()=>{
      camera.position.set(0,16,26);
      controls.target.set(0,0,0);
      controls.update();
    });

    /* ----------------------------
       ANALYSIS → VISUAL MAPPING
       We compute:
       - bass energy: bins ~20..200 Hz
       - mid energy: bins ~200..2000 Hz
       - treble energy: bins ~2k..8k Hz
       We also detect snare peaks by a simple energy threshold in 2k..6k Hz band.
       ---------------------------- */
    let pulseValue = 0; // decays every frame
    let lastSnareEnergy = 0;
    let snareAvg = 0, snareAvgSmooth = 0;

    function updateAnalysis(){
      if(!analyser) return {bass:0, mid:0, treble:0, amp:0};
      analyser.getByteFrequencyData(state.spectrum);
      analyser.getFloatTimeDomainData(state.waveform);

      // update FFT data texture (pack first 128 bins into RGBA)
      for(let i=0;i<FFT_TEX_SIZE;i++){
        const v = state.spectrum[i] / 255; // 0..1
        const j = i*4;
        fftData[j+0] = Math.floor(v*255);
        fftData[j+1] = 0;
        fftData[j+2] = 0;
        fftData[j+3] = 255;
      }
      fftTex.needsUpdate = true;

      const sr = audioCtx.sampleRate;
      const nyq = sr/2;
      const binHz = nyq / state.spectrum.length;
      const sumBand = (lo,hi)=>{
        const i0 = Math.max(0, Math.floor(lo/binHz));
        const i1 = Math.min(state.spectrum.length-1, Math.ceil(hi/binHz));
        let s=0, n=0;
        for(let i=i0;i<=i1;i++){s+=state.spectrum[i]; n++;}
        return n? s/(n*255) : 0;
      };
      const bass = sumBand(20,200);
      const mid = sumBand(200,2000);
      const treble = sumBand(2000,8000);
      const amp = (bass+mid+treble)/3;

      // naive snare detection in 2k..6k
      const sn = sumBand(2000,6000);
      snareAvg = lerp(snareAvg, sn, 0.05);
      snareAvgSmooth = lerp(snareAvgSmooth, snareAvg, 0.05);
      const isHit = sn > (snareAvgSmooth + 0.12);
      if(isHit && (performance.now() - lastSnareEnergy > 100)){
        lastSnareEnergy = performance.now();
        pulse(1.0);
        spawnSphere();
      }

      return {bass, mid, treble, amp};
    }

    // external pulse trigger for pads and detection
    function pulse(strength=1){
      pulseValue = Math.min(1.2, pulseValue + 0.6*strength);
      pMat.uniforms.uPulse.value = pulseValue;
      energyUniforms.uPulse.value = pulseValue;
      edu.msg('Pulse triggered. Shader uniforms boosted for particles and energy field.');
    }

    // City building update per frame
    function updateCity(bass){
      // Map bass energy to height. Also add small ripple by center distance.
      let i=0;
      for(let ix=0; ix<GRID; ix++){
        for(let iz=0; iz<GRID; iz++){
          const x = (ix - GRID/2);
          const z = (iz - GRID/2);
          const dist = Math.sqrt(x*x+z*z)/GRID;
          const h = 0.6 + 10.0 * bass * (1.2 - dist); // taller near center
          dummy.position.set((ix - GRID/2) * 1.2, h*0.5, (iz - GRID/2) * 1.2);
          dummy.scale.set(1, Math.max(0.2, h), 1);
          dummy.updateMatrix();
          buildings.setMatrixAt(i++, dummy.matrix);
        }
      }
      buildings.instanceMatrix.needsUpdate = true;
      const e = clamp(bass*2.5, 0, 1);
      buildings.material.emissiveIntensity = 0.25 + 0.9*e;
    }

    /* ----------------------------
       MAIN LOOP
       ---------------------------- */
    let lastT = 0;
    function tick(t){
      requestAnimationFrame(tick);
      const dt = (t - lastT)/1000; lastT = t;

      // update audio analysis
      const bands = updateAnalysis();
      energyUniforms.uTime.value = t/1000;
      energyUniforms.uAmp.value = bands?.amp || 0;

      // decay pulses
      pulseValue = Math.max(0, pulseValue - dt*1.8);
      pMat.uniforms.uTime.value = t/1000;
      pMat.uniforms.uPulse.value = pulseValue;
      energyUniforms.uPulse.value = pulseValue;

      // update city based on bass
      updateCity(bands?.bass || 0);

      // update deck time displays
      if(deckA) $('#deckATime').textContent = fmtTime(deckA.currentTime());
      if(deckB) $('#deckBTime').textContent = fmtTime(deckB.currentTime());

      // physics step
      world.step(1/60);
      for(const s of physSpheres){
        s.mesh.position.copy(s.body.position);
        s.mesh.quaternion.copy(s.body.quaternion);
        // remove after 8 seconds
        if(performance.now()-s.born>8000){
          world.remove(s.body); scene.remove(s.mesh);
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }
    requestAnimationFrame(tick);

    /* ----------------------------
       DISC AUTO ROTATION WHEN PLAYING
       purely visual. Separate from scratch transform.
       ---------------------------- */
    function spinDiscs(){
      const dA = $('#discA'), dB = $('#discB');
      const loop = ()=>{
        const base = performance.now()*0.03;
        if(deckA?.isPlaying){
          const rotA = parseFloat(dA.dataset.rot || '0');
          dA.dataset.rot = rotA + 0.6;
          dA.style.transform = `rotate(${dA.dataset.rot}deg)`;
        }
        if(deckB?.isPlaying){
          const rotB = parseFloat(dB.dataset.rot || '0');
          dB.dataset.rot = rotB + 0.6;
          dB.style.transform = `rotate(${dB.dataset.rot}deg)`;
        }
        requestAnimationFrame(loop);
      };
      loop();
    }
    spinDiscs();

    /* ----------------------------
       RECORDER STUB
       A real in-browser recorder would use MediaRecorder fed by an offline or live node.
       Here we mark as not supported in single file demo to keep scope clean.
       ---------------------------- */
    $('#recNotSupported').addEventListener('click', (e)=>{
      e.preventDefault();
      alert('Recording not included in this single-file demo. Use MediaRecorder on the master bus in your own build.');
    });

    /* ----------------------------
       INITIAL EDU NOTES
       ---------------------------- */
    edu.msg('Scratching changes playbackRate in real time. Negative rate plays backward. Returning to 1.0 restores normal speed.');
    edu.msg('City height maps bass energy. Particles and spheres pulse on snare hits detected near 2–6 kHz.');
  </script>
</body>
</html>
